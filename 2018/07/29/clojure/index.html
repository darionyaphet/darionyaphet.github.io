<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="science &amp; art"><title>clojure | Hexo</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/clojure/">clojure</a></div><div class="post-time">2018-07-29</div></div></div><div class="container post-header"><h1>clojure</h1></div><div class="container post-content"><p><code>函数式编程</code>是一种强调函数必须被当成第一等公民对待，并且这些函数是<code>纯</code>的编程方式。这是受 <code>lambda表达式</code>启发的。纯函数的意思是同一个函数对于同样的参数，它的返回值始终是一样的 — 而不会因为前一次调用修改了某个全局变量而使得后面的调用和前面调用的结果不一样。这使得这种程序十分容易理解、调试、测试。它们没有副作用 — 修改某些全局变量， 进行一些IO操作。状态被维护在方法的参数上面， 而这些参数被存放在栈上面， 而不是被维护在全局的堆上面。这使得方面可以被执行多次而不用担心它会更改什么全局的状态（这是非常重要的特征，等我们讨论事务的时候你就会意识到了）。这也使得高级编译器为了提高代码性能而对代码进行重排(reording)和并行化(parallelizing)成为可能。</p>
<blockquote>
<p>到最后，任何程序都需要修改状态，一个没有副作用的程序对我们来说只是一个黑盒， 你唯一可以感觉到的是：这个黑盒在变热。</p>
</blockquote>
<p>Clojure是一个动态类型的，主要目标是使得编写一个多线程并发访问数据程序变得简单。<br>Clojure是一个开源语言，运行在JVM上面使得Clojure代码具有可移植性，稳定性，可靠的性能以及安全性。</p>
<p><code>(function-name arg1 arg2 arg3)</code></p>
<p>Clojure里面是不支持变量的。它跟变量有点像，但是在被赋值之前是不允许改的，包括：全局binding, 线程本地binding， 以及函数内的本地binding， 以及一个表达式内部的binding。</p>
<p><code>def</code> 这个special form 定义一个全局的 binding,</p>
<p>Reference:</p>
<ol>
<li><a href="https://objectcomputing.com/resources/publications/sett/march-2009-clojure-functional-programming-for-the-jvm" target="_blank" rel="noopener">CLOJURE - FUNCTIONAL PROGRAMMING FOR THE JVM</a></li>
<li><a href="https://www.tuicool.com/articles/zMbiauJ" target="_blank" rel="noopener">Clojure入门教程: Clojure – Functional Programming for the JVM中文版</a></li>
</ol>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>