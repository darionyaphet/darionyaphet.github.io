<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="science &amp; art"><title>java | Hexo</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-time">2018-08-01</div></div></div><div class="container post-header"><h1>java</h1></div><div class="container post-content"><p><strong>JDK 各版本特性总结</strong></p>
<p><code>JDK 14</code> 无版本代号， 2020-03-17 发布。</p>
<p>特性：(还未来得及研究每个新特性，无法确认是功能的属性)</p>
<ol>
<li>instanceof的模式匹配 (预览)</li>
<li>打包工具 (Incubator)</li>
<li>G1的NUMA内存分配优化</li>
<li>JFR事件流</li>
<li>非原子性的字节缓冲区映射</li>
<li>友好的空指针异常</li>
<li>Records (预览)</li>
<li>Switch表达式 (标准)</li>
<li>弃用Solaris和SPARC端口</li>
<li>移除CMS（Concurrent Mark Sweep）垃圾收集器</li>
<li>macOS系统上的ZGC</li>
<li>Windows系统上的ZGC</li>
<li>弃用ParallelScavenge + SerialOld GC组合</li>
<li>移除Pack200 Tools和API</li>
<li>文本块 (第二个预览版)</li>
<li>外部存储器API (Incubator)</li>
</ol>
<p><code>JDK 13</code> 无版本代号， 2019-09-17 发布。</p>
<p>特性：</p>
<p>【提升】动态程序类数据共享；</p>
<p>【提升】ZGC： 释放未使用的内存；</p>
<p>【提升】Socket API</p>
<p>【提升】Switch 表达式(预览)；</p>
<p>【提升】文本块(预览)；</p>
<p><code>JDK 12</code> 无版本代号， 2019-03-19 发布。</p>
<p>特性：</p>
<p>【新增】低停顿垃圾收集器(Shenandoah， 实验)；</p>
<p>【新增】微基准套件；</p>
<p>【新增】JVM 常量 API；</p>
<p>【提升】Switch 表达式(预览)；</p>
<p>【提升】使用默认类数据共享（CDS）存档；</p>
<p>【提升】AArch64 的实现(一个端口)；</p>
<p>【提升】G1 优化，终止混合集合，能自动返回堆内存；</p>
<p><code>JDK 11</code> 无版本代号， 2018-09-25 发布。</p>
<p>特性：</p>
<p>【新增】可伸缩低延迟垃圾收集器(ZGC， 实验)；</p>
<p>【新增】基于嵌套的访问控制；</p>
<p>【新增】低开销垃圾回收器(Epsilon)；</p>
<p>【新增】低开销的 Heap Profiling；</p>
<p>【提升】标准 HTTP Client 升级；</p>
<p>【提升】启动单个源代码文件的方法；</p>
<p>【提升】Lambda 参数的局部变量语法；</p>
<p>【提升】支持 TLS 1.3 协议；</p>
<p>【提升】飞行记录器，之前只有商业版中提供；</p>
<p>【提升】动态类文件常量；</p>
<p>【提升】新增加密算法(ChaCha20 和 Poly1305)；</p>
<p>【废弃】废弃 Nashorn JavaScript 引擎、 Pack200 工具类和 API</p>
<p>【移除】移除 Java EE 和 CORBA 模块；</p>
<p><code>JDK 10</code> 无版本代号， 2018-03-20 发布。</p>
<p>特性：</p>
<p>【新增】局部变量类型推断；</p>
<p>【新增】统一的垃圾回收接口；</p>
<p>【新增】并行全垃圾回收期 G1；</p>
<p>【新增】应用程序类数据共享；</p>
<p>【新增】线程-局部管控；</p>
<p>【新增】基于 Java 的 实验性 JIT 编译器</p>
<p>【提升】基于时间的版本发布模式</p>
<p>【提升】备用存储装置上的堆分配</p>
<p>【提升】根证书认证</p>
<p>【提升】额外的 Unicode 语言标签扩展</p>
<p>【提升】整合 JDK 代码仓库；</p>
<p>【删除】移除 Native-Header 自动生成工具；</p>
<p><code>JDK 9</code> 无版本代号， 2017-09-21 发布。</p>
<p>特性：</p>
<p>【新增】模块化，进而使得 JDK 目录结构发生变化；</p>
<p>【新增】交互式编程环境 REPL(JShell)；</p>
<p>【新增】轻量级 JSON API；</p>
<p>【新增】响应式流 (Reactive Streams) API</p>
<p>【新增】HTTP 2.0 客户端；</p>
<p>【新增】多版本兼容 jar 包；</p>
<p>【新增】货币相关的 API； </p>
<p>【新增】代码分段缓存；</p>
<p>【新增】智能 Java 编译，第二阶段；</p>
<p>【提升】集合： 提供集合工厂方法；</p>
<p>【提升】接口： 私有接口方法；</p>
<p>【提升】String： 底层存储结构更换；</p>
<p>【提升】API：进程、Stream、@Deprecated、 Optional、CompletableFuture 等；</p>
<p>【提升】锁争用机制；</p>
<p>【提升】简化进程 API；</p>
<p>【提升】Javadoc 的提升</p>
<p><code>JDK 8</code> 版本代号为 Spider(蜘蛛)， 2014-03-18 发布, major.minor 版本为 52</p>
<p>特性：</p>
<p>【新增】Lambda 表达式；</p>
<p>【新增】管道和 stream；</p>
<p>【新增】新的日期和时间 API；</p>
<p>【新增】函数式接口；</p>
<p>【新增】接口的默认方法，又称为扩展方法；</p>
<p>【新增】方法与构造函数的引用；</p>
<p>【新增】Optional API；</p>
<p>【新增】并行操作；</p>
<p>【新增】新工具，如 Nashorn 引擎 jjs、类依赖分析器 jdeps；</p>
<p>【提升】支持多重注解，并新增了部分注解；</p>
<p><code>JDK 7</code> 版本代号为 Dolphin(海豚)， 2011-07-28 发布, major.minor 版本为 51</p>
<p>特性：</p>
<p>【新增】Fork and Join</p>
<p>【提升】创建泛型对象时应用类型推导， 钻石表达式；</p>
<p>【提升】自动资源管理（try-with-resources）；</p>
<p>【提升】异常捕获的处理方式（通过 | 捕获多个异常），</p>
<p>【提升】 Java NIO2 API(working with path 和 file change notification)；</p>
<p>【提升】switch 的分支条件支持字符串；</p>
<p>【提升】集合中新增 TransferQueue 接口， 是 BlockingQueue 的改进版，实现类为 LinkedTransferQueue；</p>
<p>【提升】JDBC4.1: try-with-resources 和 RowSet1.1</p>
<p>【提升】网络、Swing、XML 处理、国际化等 API 的提升</p>
<p>【提升】JVM方面， 支持非 Java 语言， Garbage-First-Collector 和提升了 Java HotSpot 虚拟机的性能；<br>reference-jdk7</p>
<p><code>JDK 6</code> 版本代号为 Mustang(野马)， 2006-12-11 发布, major.minor 版本为 50</p>
<p>特性：</p>
<p>【新增】Web 服务元数据；</p>
<p>【新增】脚本语言支持；</p>
<p>【新增】JTable 的排序和过滤；</p>
<p>【新增】轻量级的 Http Server；</p>
<p>【新增】插入式注解处理 API(Pluggable Annotation Processing API)；</p>
<p>【新增】支持嵌入式数据库 Derby；</p>
<p>【新增】Console API；</p>
<p>【新增】Compile API；</p>
<p>【新增】StAX(Streaming API for XML) 处理 XML；</p>
<p>【提升】引入 JAXB2 来处理对象和 XML 之间的映射；</p>
<p>【提升】AWT 中新增了两个类 Desktop 和 SystemTray， 极不常用；</p>
<p>【提升】Common Annotations；</p>
<p>【提升】JAX-WS2.0；</p>
<p>【提升】JDBC4.0；</p>
<p>【提升】引入新的 GC 算法；</p>
<p><code>JDK 5</code> 版本代号为 Tiger(老虎)， 2004-09-30 发布, major.minor 版本为 49。从 JDK5 开始， JDK 的版本不再以 1.x 的方式来命名了， 而是直接用 x 来命名。</p>
<p>特性：</p>
<p>【新增】泛型</p>
<p>【新增】增强 for 循环， 可以使用迭代方式；</p>
<p>【新增】自动装箱与自动拆箱；</p>
<p>【新增】类型安全的枚举；</p>
<p>【新增】支持可变参数；</p>
<p>【新增】静态导入；</p>
<p>【新增】注解： 动态注解、元数据；</p>
<p>【新增】Instrumentation；</p>
<p>【新增】内省(Introspector)</p>
<p>【新增】JUC 包</p>
<p>【新增】Scanner 类</p>
<p><code>JDK 1.4</code> 版本代号为 Merlin(隼)， 2004-02-06 发布(首次在 JCP 下发行), major.minor 版本为 48</p>
<p>特性：</p>
<p>【新增】XML处理;</p>
<p>【新增】Java打印服务;</p>
<p>【新增】Logging API;</p>
<p>【新增】Java Web Start;</p>
<p>【新增】断言;</p>
<p>【新增】引入Preferences API;</p>
<p>【新增】链式异常处理;</p>
<p>【新增】支持IPV6;</p>
<p>【新增】正则表达式;</p>
<p>【新增】Image I/O API；</p>
<p>【新增】NIO API；</p>
<p>【新增】集成 JCE、JSSE、JAAS；</p>
<p>【提升】引入JDBC 3.0 API;</p>
<p><code>JDK 1.3</code><br>版本代号为 Kestrel(红隼)， 2000-05-08 发布, major.minor 版本为 47</p>
<p>特性：</p>
<p>【新增】Java Sound API， 已被淘汰；</p>
<p>【新增】jar文件索引；</p>
<p>【新增】JVM 配备 HotSpot JVM；</p>
<p>【新增】代理类；</p>
<p>【新增】Java 命名与目录接口；</p>
<p>【新增】Java 平台调试体系；</p>
<p><code>JDK 1.2</code><br>版本代号为 Playground(操场)， 1998-12-08 发布, major.minor 版本为 46</p>
<p>特性：</p>
<p>【新增】集合框架；</p>
<p>【新增】对字符串常量做内存映射；</p>
<p>【新增】JIT(Just In Time) 编译器；</p>
<p>【新增】对打包的 Java 文件进行数字签名；</p>
<p>【新增】控制授权访问系统资源的策略工具；</p>
<p>【新增】JFC(Java Foundation Classes)， 包括 Swing 1.0， 拖放和 Java2D 类库，很少使用， 主要的使用场景是用在后端生<br>成图片的业务场景， 如二维码生成；</p>
<p>【新增】Java 插件；</p>
<p>【新增】strictfp 关键字；</p>
<p>【提升】在 JDBC 中引入可滚动结果集， BLOB， CLOB， 批量更新和用户自定义类型；</p>
<p>【提升】在 Applet 中添加声音支持， 已被淘汰；</p>
<p><code>JDK 1.1</code> 无版本代号, 1997-02-19 发布, major.minor 版本为 45</p>
<p>特性：</p>
<p>【新增】JDBC(Java Database Connectivity)， 注意不是 Connection；</p>
<p>【新增】内部类；</p>
<p>【新增】Java Bean；</p>
<p>【新增】RMI(Remote Method Invocation)；</p>
<p>【新增】反射(仅用于内省)；</p>
<p>【提升】IO 引入 Reader/Writer 及其子类；</p>
<p><code>JDK 1.0</code> 版本代号为 Oak(橡树)， 1996-01-23 发布</p>
<p>主要特性：</p>
<p>【新增】JVM；</p>
<p>【新增】Applet: 已被淘汰；</p>
<p>【新增】AWT(Abstract Window ToolKit): 已被淘汰；</p>
<p>【新增】File 和 IO(InputStream/OutputStream) 相关操作 API；</p>
<hr>
<p><strong>Java Iterator to Java 8 Stream</strong></p>
<p><code>Iterator</code> cannot be used as a stream but <code>Iterable</code> can, we just create a new <code>Iterable</code> class which overrides its <code>iterator()</code> method to return the <code>Iterator</code> we want to stream.</p>
<p><code>Iterable</code> is not streamable yet. So we use <code>StreamSupport</code> class to convert the <code>Iterable</code> to a <code>Stream</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; elements = Arrays.asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line">Iterator&lt;Integer&gt; iterator = elements.iterator();</span><br><span class="line">Iterable&lt;Integer&gt; iterable = () -&gt; iterator;</span><br><span class="line">List&lt;Integer&gt; list = stream(iterable.spliterator(), false)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>Java 8: Declare Private and Protected Methods in Interfaces</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package org.darion.yaphet.examples.jdk8;</span><br><span class="line"></span><br><span class="line">public interface Foo &#123;</span><br><span class="line"></span><br><span class="line">    default int bar() &#123;</span><br><span class="line">        return Hidden.complicatedMethodWithManyLinesOfCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default int bazz() &#123;</span><br><span class="line">        return Hidden.complicatedMethodWithManyLinesOfCode() + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Hidden &#123;</span><br><span class="line">        private static int complicatedMethodWithManyLinesOfCode() &#123;</span><br><span class="line">            // Actual code not shown...</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>40 Java Collections Interview Questions and Answers</strong></p>
<hr>
<p><strong>Java 8 Interface Default</strong></p>
<hr>
<p><strong>Lock</strong></p>
<blockquote>
<p>公平锁/非公平锁</p>
<blockquote>
<p>公平锁:多个线程按照申请锁的顺序来获取锁。 </p>
<p>非公平锁:多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。</p>
</blockquote>
</blockquote>
<blockquote>
<p>可重入锁/不可重入锁</p>
<blockquote>
<p>可重入锁:可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁。<br>不可重入锁:</p>
</blockquote>
</blockquote>
<p>Currently, we using <code>git-lfs</code> to manage the 3rd-party libraries. You should make sure <code>git-lfs</code> have been installed before building the source code.</p>
<p>Please see <a href="https://github.com/git-lfs/git-lfs/blob/master/INSTALLING.md" target="_blank" rel="noopener">INSTALLING.md</a> for more details.</p>
<hr>
<p><strong>Promise 模式</strong></p>
<p>Promise 模式是一种异步编程模式 。它使得我们可以先开始一个任务的执行，并得到一个用于获取该任务执行结果的凭据对象，而不必等待该任务执行完毕就可以继续执行其他操作。等到我们需要该任务的执行结果时，再调用凭据对象的相关方法来获取。<br>Promise 模式中，客户端代码调用某个异步方法所得到的返回值仅是一个凭据对象（Promise，意为“承诺”）。凭借该对象，客户端代码可以获取异步方法相应的真正任务的执行结果。</p>
<hr>
<p><strong><em>Reference</em></strong> :</p>
<ol>
<li><a href="https://www.javacodegeeks.com/2018/08/java-iterator-stream.html" target="_blank" rel="noopener">Java Iterator to Java 8 Stream</a></li>
<li><a href="https://www.javacodegeeks.com/2013/02/40-java-collections-interview-questions-and-answers.html" target="_blank" rel="noopener">40 Java Collections Interview Questions and Answers</a></li>
<li><a href="https://www.infoq.cn/article/design-patterns-promise/" target="_blank" rel="noopener">Java 多线程编程模式实战指南之 Promise 模式</a></li>
</ol>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>