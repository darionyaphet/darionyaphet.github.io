<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="science &amp; art"><title>cpp | Hexo</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-time">2019-06-28</div></div></div><div class="container post-header"><h1>cpp</h1></div><div class="container post-content"><p><strong><strong>attribute</strong></strong></p>
<p><code>__attribute__</code> 可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute ）。</p>
<p><code>__attribute__</code> 书写特征是：<code>__attribute__</code> 前后都有两个下划线，并切后面会紧跟一对原括弧，括弧里面是相应的参数。</p>
<p><code>__attribute__</code> 语法格式为：<strong>attribute</strong> ((attribute-list))</p>
<p>其位置约束为：放于声明的尾部“ ；” 之前。</p>
<p>关键字<code>__attribute__</code> 也可以对结构体（struct ）或共用体（union ）进行属性设置。</p>
<p>大致有六个参数值可以被设定，即：aligned, packed, transparent_union, unused, deprecated 和 may_alias 。</p>
<p>在使用<code>__attribute__</code> 参数时，你也可以在参数的前后都加上“<strong>” （两个下划线），例如，使用</strong>aligned__而不是aligned ，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>aligned</td>
<td>设定一个指定大小的对齐格式。</td>
</tr>
<tr>
<td>packed</td>
<td>使用该属性对struct 或者union 类型进行定义，设定其类型的每一个变量的内存约束。</td>
</tr>
<tr>
<td>Function Attribute</td>
<td>把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。</td>
</tr>
</tbody>
</table>
<p><code>__attribute__((constructor))</code> 在main() 之前执行, <code>__attribute__((destructor))</code> 在main()执行结束之后执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>  __attribute__((constructor)) <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>  __attribute__((destructor)) <span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" World!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> args, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong><strong>func</strong></strong></p>
<p><code>__func__</code> 返回所在函数名字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> __func__; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">world</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> __func__; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">darion</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> __func__; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hello() &lt;&lt; <span class="string">", "</span> &lt;&lt; world() &lt;&lt; <span class="string">" "</span> &lt;&lt; darion() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// hello, world darion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>_Pragma</strong></p>
<p><code>#pragma</code> 向编译器传递语言标准之外的一些信息。</p>
<p>头文件中定义 <code>#pragma once</code>，指示编译器该头文件只编译一次。</p>
<p><code>_Pragma</code> 功能与 <code>#pragma</code> 类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Pragma(&quot;once&quot;);</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>左值&amp;右值</strong></p>
<p><code>左值</code>指的是既能够出现在等号左边也能出现在等号右边的变量或表达式</p>
<p><code>右值</code>指的则是只能出现在等号右边的变量或表达式</p>
<p>有名字的变量就是左值，而由运算操作所产生的中间结果就是右值(1+2)</p>
<p><code>左值</code>就是在程序中能够寻值的东西，<code>右值</code>就是没法取到它的地址的东西</p>
<p>对于基础类型，右值是不可被修改的，也不可被 const, volatile 所修饰</p>
<p>对于自定义的类型，右值却允许通过它的成员函数进行修改</p>
<p><code>左值</code>是可以放在赋值号左边可以被赋值的值；<code>左值</code>必须要在内存中有实体；</p>
<p><code>右值</code>当在赋值号右边取出值赋给其他变量的值；<code>右值</code>可以在内存也可以在CPU寄存器。</p>
<p><code>右值引用</code> 支持移动语义的实现, 利用移动语义，可以编写将资源从一个对象转移到另一个对象。</p>
<hr>
<p><strong>RAII</strong></p>
<p><code>RAII</code>全称是<code>Resource Acquisition is Initialization</code>，直译过来是<code>资源获取即初始化</code>，也就是说在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</p>
<p>智能指针（<code>std::shared_ptr</code>和<code>std::unique_ptr</code>）即<code>RAII</code>最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p>
<hr>
<p><strong>Thread</strong></p>
<hr>
<p><strong>noexcept</strong></p>
<p>该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Type&amp; x, Type&amp; y)</span> <span class="keyword">noexcept</span>  <span class="comment">//C++11</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.swap(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有条件的noexcecpt</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果操作x.swap(y)不发生异常，那么函数swap(Type&amp; x, Type&amp; y)一定不发生异常。</span></span><br><span class="line">void swap(Type&amp; x, Type&amp; y) noexcept(noexcept(x.swap(y)))    //C++11</span><br><span class="line">&#123;</span><br><span class="line">    x.swap(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>STL</strong></p>
<p><code>慎重选择容器类型</code></p>
<ul>
<li>连续内存容器: 元素存放在一块或多块内存，每块内存中存有多个元素。</li>
<li>每一个内存块中只存储一个元素。</li>
</ul>
<ol>
<li>是否需要在容器任意位置插入新元素？</li>
<li>是否关心容器中元素是如何排序的？</li>
<li>必须是C++标准一部分吗？</li>
<li>需要那种类型迭代器？</li>
<li>容器中数据布局是否与C兼容？</li>
<li>元素查找速度是否是考虑关键？</li>
<li>是否介意引用计数？</li>
</ol>
<p><code>不要试图编写独立于容器类型的代码</code></p>
<p>数组被泛化为<code>以其包含的对象的类型为参数</code>，函数被泛化为<code>以其使用的迭代器类型为参数</code>。</p>
<p><code>确保容器中的对象拷贝正确而高效</code></p>
<p><code>调用empty 而不是检查size()是否为0</code></p>
<p><code>区间成员函数优先于与之对应的单元素成员函数</code></p>
<p><code>当心C++编译器最烦人的分析机制</code></p>
<p><code>如果容器中包含了通过new 操作创建的指针，切记在容器对象析构前将指针delete 掉</code></p>
<p><code>切勿创建包含auto_ptr 的容器对象</code></p>
<p><code>慎重选择删除元素的方法</code></p>
<p><code>了解分配子（allocator）的约定和限制</code></p>
<p><code>理解自定义分配子的合理用法</code></p>
<p><code>切勿对STL 容器的线程安全性有不切实际的依赖</code></p>
<p><code>vector 和string 优先于动态分配的数组</code></p>
<p><code>使用reserve 来避免不必要的重新分配</code></p>
<p><code>注意string 实现的多样性</code></p>
<p><code>了解如何把vector 和string 数据传给旧的API</code></p>
<p><code>使用“swap 技巧”除去多余的容量</code></p>
<p><code>避免使用vector&lt;bool&gt;</code></p>
<p><code>理解相等（equality）和等价（equivalence）的区别</code></p>
<p><code>为包含指针的关联容器指定比较类型</code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<hr>
<p><strong>SFINAE</strong></p>
<p>Substitution failure is not an error: 匹配失败不是错误</p>
<p>当调用模板函数时编译器会根据传入参数推导最合适的模板函数，在这个推导过程中如果某一个或者某几个模板函数推导出来是编译无法通过的，只要有一个可以正确推导出来，那么那几个推导得到的可能产生编译错误的模板函数并不会引发编译错误。</p>
<hr>
<p><strong>Differences between std::make_unique and std::unique_ptr with new</strong></p>
<p>make_unique is safe for creating temporaries, whereas with explicit use of new you have to remember the rule about not using unnamed temporaries.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo(make_unique&lt;T&gt;(), make_unique&lt;U&gt;()); // exception safe</span><br><span class="line"></span><br><span class="line">foo(unique_ptr&lt;T&gt;(new T()), unique_ptr&lt;U&gt;(new U())); // unsafe*</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>STL</strong></p>
<ul>
<li>容器(container)：常用数据结构，大致分为两类，序列容器，如vector，list，deque，关联容器，如set，map。在实现上，是类模板(class template)</li>
<li>迭代器(iterator)：一套访问容器的接口，行为类似于指针。它为不同算法提供的相对统一的容器访问方式，使得设计算法时无需关注过多关注数据。</li>
<li>算法(algorithm)：提供一套常用的算法，如sort，search，copy，erase … 在实现上，可以认为是一种函数模板(function template)。</li>
<li>配置器(allocator)：为容器提供空间配置和释放，对象构造和析构的服务，也是一个class template。</li>
<li>仿函数(functor)：作为函数使用的对象，用于泛化算法中的操作。</li>
<li>配接器(adapter)：将一种容器修饰为功能不同的另一种容器，如以容器vector为基础，在其上实现stack，stack的行为也是一种容器。这就是一种配接器。除此之外，还有迭代器配接器和仿函数配接器。</li>
</ul>
<hr>
<p><strong>Memory Order</strong></p>
<p><code>std::memory_order</code> 指定内存访问，包括常规的非原子内存访问，如何围绕原子操作排序。在没有任何制约的多处理器系统上，多个线程同时读或写数个变量时，一个线程能观测到变量值更改的顺序不同于另一个线程写它们的顺序。其实，更改的顺序甚至能在多个读取线程间相异。一些类似的效果还能在单处理器系统上出现，因为内存模型允许编译器变换。</p>
<p>库中所有原子操作的默认行为提供序列一致顺序。该默认行为可能有损性能，不过可以给予库的原子操作额外的 std::memory_order 参数，以指定附加制约，在原子性外，编译器和处理器还必须强制该操作。</p>
<table>
<thead>
<tr>
<th>Option name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>memory_order_relaxed</code></td>
<td>宽松操作：没有同步或顺序制约，仅对此操作要求原子性。</td>
<td></td>
</tr>
<tr>
<td><code>memory_order_consume</code></td>
<td>有此内存顺序的加载操作，在其影响的内存位置进行消费操作：当前线程中依赖于当前加载的该值的读或写不能被重排到此加载前。其他释放同一原子变量的线程的对数据依赖变量的写入，为当前线程所可见。在大多数平台上，这只影响到编译器优化。</td>
<td></td>
</tr>
<tr>
<td><code>memory_order_acquire</code></td>
<td>有此内存顺序的加载操作，在其影响的内存位置进行获得操作：当前线程中读或写不能被重排到此加载前。其他释放同一原子变量的线程的所有写入，能为当前线程所见。</td>
<td></td>
</tr>
<tr>
<td><code>memory_order_release</code></td>
<td>有此内存顺序的存储操作进行释放操作：当前线程中的读或写不能被重排到此存储后。当前线程的所有写入，可见于获得该同一原子变量的其他线程释放获得顺序），并且对该原子变量的带依赖写入变得对于其他消费同一原子对象的线程可见。</td>
<td></td>
</tr>
<tr>
<td><code>memory_order_acq_rel</code></td>
<td>带此内存顺序的读修改写操作既是获得操作又是释放操作。当前线程的读或写内存不能被重排到此存储前或后。所有释放同一原子变量的线程的写入可见于修改之前，而且修改可见于其他获得同一原子变量的线程。</td>
<td></td>
</tr>
<tr>
<td><code>memory_order_seq_cst</code></td>
<td>有此内存顺序的加载操作进行获得操作，存储操作进行释放操作，而读修改写操作进行获得操作和释放操作，再加上存在一个单独全序，其中所有线程以同一顺序观测到所有修改。</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>memory_order_acq_rel</code>并不是一个内存模型，只是<code>memory_order_acquire</code>和<code>memory_order_release</code>的合并，在一些读取并修改的操作中会用到。</p>
<p><code>memory_order_seq_cst</code> / <code>memory_order_seq_cst</code> : <code>seq_cst</code>是<code>sequentially consistent</code>的缩写，持严格的代码线性执行顺序。</p>
<p><code>memory_order_acquire</code> / <code>memory_order_release</code> : 这种模型比memory_order_seq_cst稍微宽松一些，它移除了不相关的原子变量的顺序一致性。</p>
<p><code>memory_order_consume</code> / <code>memory_order_release</code> : 这种内存模型又比<code>memory_order_seq_cst</code>更加宽松，它不仅移除了不相关的原子变量的顺序一致性，还移除了不相关普通变量的一致性。 </p>
<p><code>memory_order_relaxed</code> : 这种模型最宽松，他并不对任何顺序做保证，仅仅保证操作的原子性。</p>
<p><strong>Relaxed ordering</strong></p>
<p><code>std::atomic</code>的<code>load()</code>和<code>store()</code>都要带上<code>memory_order_relaxed</code>参数。</p>
<p>仅仅保证<code>load()</code>和<code>store()</code>是原子操作，除此之外，不提供任何跨线程的同步。</p>
<p><strong>Release-Acquire ordering</strong></p>
<p><code>store()</code>使用<code>memory_order_release</code>，而<code>load()</code>使用<code>memory_order_acquire</code>。</p>
<p>这种模型有两种效果，第一种是可以限制 CPU 指令的重排：</p>
<ul>
<li>在<code>store()</code>之前的所有读写操作，不允许被移动到这个<code>store()</code>的后面。</li>
<li>在<code>load()</code>之后的所有读写操作，不允许被移动到这个<code>load()</code>的前面。</li>
</ul>
<p>Sequential consistency有两个特性</p>
<ol>
<li>所有线程执行指令的顺序都是按照源代码的顺序；</li>
<li>每个线程所能看到其他线程的操作的执行顺序都是一样的。</li>
</ol>
<p>Acquire-release: 在同一个原子变量的release操作和acquire操作间同步，同时也就建立起了执行序列约束。所有的读和写动作不能移动到acquire操作之前。所有的读和写动作不能移动到release操作之后。</p>
<p>std::memory_order_consume</p>
<ol>
<li>carries-a-dependency-to：如果操作A的结果用于操作B的操作当中，那么A carries-a-dependency-to（将依赖带入） B</li>
<li>dependency-ordered-before：如果操作B的结果进一步在相同的线程内被操作C使用，那么A的store操作是dependency-ordered-before（在依赖执行序列X之前）B的load操作(with std::memory_order_consume)。</li>
</ol>
<hr>
<p>Reference:</p>
<ol>
<li><a href="https://www.cnblogs.com/jiangbin/p/6986511.html" target="_blank" rel="noopener">C++中的RAII介绍</a></li>
<li><a href="https://www.jianshu.com/p/2b100d78a315" target="_blank" rel="noopener">C++之左值、右值、左值引用、右值引用</a></li>
<li><a href="https://www.cnblogs.com/sword03/p/10020344.html" target="_blank" rel="noopener">C++11 带来的新特性 （3）—— 关键字noexcept</a></li>
<li><a href="pan.baidu.com">EFFECTIVE+STL中文版：50条有效使用STL的经验_11577044</a></li>
<li><a href="https://www.jianshu.com/p/d19fc8447eaa" target="_blank" rel="noopener">[c++11]我理解的右值引用、移动语义和完美转发</a></li>
<li><a href="https://www.cnblogs.com/embedded-linux/p/5801999.html" target="_blank" rel="noopener">C之attribute用法</a></li>
<li><a href="https://isocpp.org/blog/2019/06/quick-q-differences-between-stdmake-unique-and-stdunique-ptr-with-new" target="_blank" rel="noopener">Differences between std::make_unique and std::unique_ptr with new</a></li>
<li><a href="https://zh.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener">cppreference: memory_order</a></li>
<li><a href="http://senlinzhan.github.io/2017/12/04/cpp-memory-order/" target="_blank" rel="noopener">理解 C++ 的 Memory Order</a></li>
<li><a href="https://tyzual.com/2019/02/11/mem-order/" target="_blank" rel="noopener">C++11 中的内存模型</a></li>
<li><a href="https://www.cnblogs.com/navono007/p/5746048.html" target="_blank" rel="noopener">C++11内存模型的粗略解释</a></li>
</ol>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>