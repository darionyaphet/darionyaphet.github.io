<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="science &amp; art"><title>cpp | Hexo</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-time">2019-06-28</div></div></div><div class="container post-header"><h1>cpp</h1></div><div class="container post-content"><p><strong>.inl 文件</strong></p>
<p>内联函数较多的情况下，为了避免头文件过长，可以将所有的内联函数定义移到一个单独的文件中去，然后再用#include指令将它包含到类声明的后面（类的头文件的底部）。这样的文件称为一个内联函数定义文件。inl文件中也可以包含头文件的，因为内联函数中可能包含其他文件中定义的东西。</p>
<hr>
<p><strong><strong>attribute</strong></strong></p>
<p><code>__attribute__</code> 可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute ）。</p>
<p><code>__attribute__</code> 书写特征是：<code>__attribute__</code> 前后都有两个下划线，并切后面会紧跟一对原括弧，括弧里面是相应的参数。</p>
<p><code>__attribute__</code> 语法格式为：<strong>attribute</strong> ((attribute-list))</p>
<p>其位置约束为：放于声明的尾部“ ；” 之前。</p>
<p>关键字<code>__attribute__</code> 也可以对结构体（struct ）或共用体（union ）进行属性设置。</p>
<p>大致有六个参数值可以被设定，即：aligned, packed, transparent_union, unused, deprecated 和 may_alias 。</p>
<p>在使用<code>__attribute__</code> 参数时，你也可以在参数的前后都加上“<strong>” （两个下划线），例如，使用</strong>aligned__而不是aligned ，这样，你就可以在相应的头文件里使用它而不用关心头文件里是否有重名的宏定义。</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>aligned</td>
<td>设定一个指定大小的对齐格式。</td>
</tr>
<tr>
<td>packed</td>
<td>使用该属性对struct 或者union 类型进行定义，设定其类型的每一个变量的内存约束。</td>
</tr>
<tr>
<td>Function Attribute</td>
<td>把一些特性添加到函数声明中，从而可以使编译器在错误检查方面的功能更强大。</td>
</tr>
</tbody>
</table>
<p><code>__attribute__((constructor))</code> 在main() 之前执行, <code>__attribute__((destructor))</code> 在main()执行结束之后执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>  __attribute__((constructor)) <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>  __attribute__((destructor)) <span class="function"><span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" World!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> args, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong><strong>func</strong></strong></p>
<p><code>__func__</code> 返回所在函数名字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> __func__; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">world</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> __func__; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">darion</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> __func__; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hello() &lt;&lt; <span class="string">", "</span> &lt;&lt; world() &lt;&lt; <span class="string">" "</span> &lt;&lt; darion() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// hello, world darion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>_Pragma</strong></p>
<p><code>#pragma</code> 向编译器传递语言标准之外的一些信息。</p>
<p>头文件中定义 <code>#pragma once</code>，指示编译器该头文件只编译一次。</p>
<p><code>_Pragma</code> 功能与 <code>#pragma</code> 类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Pragma(&quot;once&quot;);</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>左值&amp;右值</strong></p>
<p><code>左值</code>指的是既能够出现在等号左边也能出现在等号右边的变量或表达式</p>
<p><code>右值</code>指的则是只能出现在等号右边的变量或表达式</p>
<p>有名字的变量就是左值，而由运算操作所产生的中间结果就是右值(1+2)</p>
<p><code>左值</code>就是在程序中能够寻值的东西，<code>右值</code>就是没法取到它的地址的东西</p>
<p>对于基础类型，右值是不可被修改的，也不可被 const, volatile 所修饰</p>
<p>对于自定义的类型，右值却允许通过它的成员函数进行修改</p>
<p><code>左值</code>是可以放在赋值号左边可以被赋值的值；<code>左值</code>必须要在内存中有实体；</p>
<p><code>右值</code>当在赋值号右边取出值赋给其他变量的值；<code>右值</code>可以在内存也可以在CPU寄存器。</p>
<p><code>右值引用</code> 支持移动语义的实现, 利用移动语义，可以编写将资源从一个对象转移到另一个对象。</p>
<hr>
<p><strong>RAII</strong></p>
<p><code>RAII</code>全称是<code>Resource Acquisition is Initialization</code>，直译过来是<code>资源获取即初始化</code>，也就是说在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</p>
<p>智能指针（<code>std::shared_ptr</code>和<code>std::unique_ptr</code>）即<code>RAII</code>最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p>
<hr>
<p><strong>Thread</strong></p>
<hr>
<p><strong>noexcept</strong></p>
<p>该关键字告诉编译器，函数中不会发生异常,这有利于编译器对程序做更多的优化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Type&amp; x, Type&amp; y)</span> <span class="keyword">noexcept</span>  <span class="comment">//C++11</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x.swap(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有条件的noexcecpt</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果操作x.swap(y)不发生异常，那么函数swap(Type&amp; x, Type&amp; y)一定不发生异常。</span></span><br><span class="line">void swap(Type&amp; x, Type&amp; y) noexcept(noexcept(x.swap(y)))    //C++11</span><br><span class="line">&#123;</span><br><span class="line">    x.swap(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>STL</strong></p>
<p><code>慎重选择容器类型</code></p>
<ul>
<li>连续内存容器: 元素存放在一块或多块内存，每块内存中存有多个元素。</li>
<li>每一个内存块中只存储一个元素。</li>
</ul>
<ol>
<li>是否需要在容器任意位置插入新元素？</li>
<li>是否关心容器中元素是如何排序的？</li>
<li>必须是C++标准一部分吗？</li>
<li>需要那种类型迭代器？</li>
<li>容器中数据布局是否与C兼容？</li>
<li>元素查找速度是否是考虑关键？</li>
<li>是否介意引用计数？</li>
</ol>
<p><code>不要试图编写独立于容器类型的代码</code></p>
<p>数组被泛化为<code>以其包含的对象的类型为参数</code>，函数被泛化为<code>以其使用的迭代器类型为参数</code>。</p>
<p><code>确保容器中的对象拷贝正确而高效</code></p>
<p><code>调用empty 而不是检查size()是否为0</code></p>
<p><code>区间成员函数优先于与之对应的单元素成员函数</code></p>
<p><code>当心C++编译器最烦人的分析机制</code></p>
<p><code>如果容器中包含了通过new 操作创建的指针，切记在容器对象析构前将指针delete 掉</code></p>
<p><code>切勿创建包含auto_ptr 的容器对象</code></p>
<p><code>慎重选择删除元素的方法</code></p>
<p><code>了解分配子（allocator）的约定和限制</code></p>
<p><code>理解自定义分配子的合理用法</code></p>
<p><code>切勿对STL 容器的线程安全性有不切实际的依赖</code></p>
<p><code>vector 和string 优先于动态分配的数组</code></p>
<p><code>使用reserve 来避免不必要的重新分配</code></p>
<p><code>注意string 实现的多样性</code></p>
<p><code>了解如何把vector 和string 数据传给旧的API</code></p>
<p><code>使用“swap 技巧”除去多余的容量</code></p>
<p><code>避免使用vector&lt;bool&gt;</code></p>
<p><code>理解相等（equality）和等价（equivalence）的区别</code></p>
<p><code>为包含指针的关联容器指定比较类型</code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<p><code></code></p>
<hr>
<p><strong>SFINAE</strong></p>
<p>Substitution failure is not an error: 匹配失败不是错误</p>
<p>当调用模板函数时编译器会根据传入参数推导最合适的模板函数，在这个推导过程中如果某一个或者某几个模板函数推导出来是编译无法通过的，只要有一个可以正确推导出来，那么那几个推导得到的可能产生编译错误的模板函数并不会引发编译错误。</p>
<hr>
<p><strong>Differences between std::make_unique and std::unique_ptr with new</strong></p>
<p>make_unique is safe for creating temporaries, whereas with explicit use of new you have to remember the rule about not using unnamed temporaries.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo(make_unique&lt;T&gt;(), make_unique&lt;U&gt;()); // exception safe</span><br><span class="line"></span><br><span class="line">foo(unique_ptr&lt;T&gt;(new T()), unique_ptr&lt;U&gt;(new U())); // unsafe*</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>STL</strong></p>
<ul>
<li>容器(container)：常用数据结构，大致分为两类，序列容器，如vector，list，deque，关联容器，如set，map。在实现上，是类模板(class template)</li>
<li>迭代器(iterator)：一套访问容器的接口，行为类似于指针。它为不同算法提供的相对统一的容器访问方式，使得设计算法时无需关注过多关注数据。</li>
<li>算法(algorithm)：提供一套常用的算法，如sort，search，copy，erase … 在实现上，可以认为是一种函数模板(function template)。</li>
<li>配置器(allocator)：为容器提供空间配置和释放，对象构造和析构的服务，也是一个class template。</li>
<li>仿函数(functor)：作为函数使用的对象，用于泛化算法中的操作。</li>
<li>配接器(adapter)：将一种容器修饰为功能不同的另一种容器，如以容器vector为基础，在其上实现stack，stack的行为也是一种容器。这就是一种配接器。除此之外，还有迭代器配接器和仿函数配接器。</li>
</ul>
<hr>
<p><strong>Memory Order</strong></p>
<p><code>std::memory_order</code> 指定内存访问，包括常规的非原子内存访问，如何围绕原子操作排序。在没有任何制约的多处理器系统上，多个线程同时读或写数个变量时，一个线程能观测到变量值更改的顺序不同于另一个线程写它们的顺序。其实，更改的顺序甚至能在多个读取线程间相异。一些类似的效果还能在单处理器系统上出现，因为内存模型允许编译器变换。</p>
<p>库中所有原子操作的默认行为提供序列一致顺序。该默认行为可能有损性能，不过可以给予库的原子操作额外的 std::memory_order 参数，以指定附加制约，在原子性外，编译器和处理器还必须强制该操作。</p>
<table>
<thead>
<tr>
<th>Option name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>memory_order_relaxed</code></td>
<td>宽松操作：没有同步或顺序制约，仅对此操作要求原子性。</td>
<td></td>
</tr>
<tr>
<td><code>memory_order_consume</code></td>
<td>有此内存顺序的加载操作，在其影响的内存位置进行消费操作：当前线程中依赖于当前加载的该值的读或写不能被重排到此加载前。其他释放同一原子变量的线程的对数据依赖变量的写入，为当前线程所可见。在大多数平台上，这只影响到编译器优化。</td>
<td></td>
</tr>
<tr>
<td><code>memory_order_acquire</code></td>
<td>有此内存顺序的加载操作，在其影响的内存位置进行获得操作：当前线程中读或写不能被重排到此加载前。其他释放同一原子变量的线程的所有写入，能为当前线程所见。</td>
<td></td>
</tr>
<tr>
<td><code>memory_order_release</code></td>
<td>有此内存顺序的存储操作进行释放操作：当前线程中的读或写不能被重排到此存储后。当前线程的所有写入，可见于获得该同一原子变量的其他线程释放获得顺序），并且对该原子变量的带依赖写入变得对于其他消费同一原子对象的线程可见。</td>
<td></td>
</tr>
<tr>
<td><code>memory_order_acq_rel</code></td>
<td>带此内存顺序的读修改写操作既是获得操作又是释放操作。当前线程的读或写内存不能被重排到此存储前或后。所有释放同一原子变量的线程的写入可见于修改之前，而且修改可见于其他获得同一原子变量的线程。</td>
<td></td>
</tr>
<tr>
<td><code>memory_order_seq_cst</code></td>
<td>有此内存顺序的加载操作进行获得操作，存储操作进行释放操作，而读修改写操作进行获得操作和释放操作，再加上存在一个单独全序，其中所有线程以同一顺序观测到所有修改。</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>memory_order_acq_rel</code>并不是一个内存模型，只是<code>memory_order_acquire</code>和<code>memory_order_release</code>的合并，在一些读取并修改的操作中会用到。</p>
<p><code>memory_order_seq_cst</code> / <code>memory_order_seq_cst</code> : <code>seq_cst</code>是<code>sequentially consistent</code>的缩写，持严格的代码线性执行顺序。</p>
<p><code>memory_order_acquire</code> / <code>memory_order_release</code> : 这种模型比memory_order_seq_cst稍微宽松一些，它移除了不相关的原子变量的顺序一致性。</p>
<p><code>memory_order_consume</code> / <code>memory_order_release</code> : 这种内存模型又比<code>memory_order_seq_cst</code>更加宽松，它不仅移除了不相关的原子变量的顺序一致性，还移除了不相关普通变量的一致性。 </p>
<p><code>memory_order_relaxed</code> : 这种模型最宽松，他并不对任何顺序做保证，仅仅保证操作的原子性。</p>
<p><strong>Relaxed ordering</strong></p>
<p><code>std::atomic</code>的<code>load()</code>和<code>store()</code>都要带上<code>memory_order_relaxed</code>参数。</p>
<p>仅仅保证<code>load()</code>和<code>store()</code>是原子操作，除此之外，不提供任何跨线程的同步。</p>
<p><strong>Release-Acquire ordering</strong></p>
<p><code>store()</code>使用<code>memory_order_release</code>，而<code>load()</code>使用<code>memory_order_acquire</code>。</p>
<p>这种模型有两种效果，第一种是可以限制 CPU 指令的重排：</p>
<ul>
<li>在<code>store()</code>之前的所有读写操作，不允许被移动到这个<code>store()</code>的后面。</li>
<li>在<code>load()</code>之后的所有读写操作，不允许被移动到这个<code>load()</code>的前面。</li>
</ul>
<p>Sequential consistency有两个特性</p>
<ol>
<li>所有线程执行指令的顺序都是按照源代码的顺序；</li>
<li>每个线程所能看到其他线程的操作的执行顺序都是一样的。</li>
</ol>
<p>Acquire-release: 在同一个原子变量的release操作和acquire操作间同步，同时也就建立起了执行序列约束。所有的读和写动作不能移动到acquire操作之前。所有的读和写动作不能移动到release操作之后。</p>
<p>std::memory_order_consume</p>
<ol>
<li>carries-a-dependency-to：如果操作A的结果用于操作B的操作当中，那么A carries-a-dependency-to（将依赖带入） B</li>
<li>dependency-ordered-before：如果操作B的结果进一步在相同的线程内被操作C使用，那么A的store操作是dependency-ordered-before（在依赖执行序列X之前）B的load操作(with std::memory_order_consume)。</li>
</ol>
<hr>
<p><code>SFINAE</code>(Substitution Failure Is Not An Error) 从一组重载函数中删除模板实例化无效的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Prune functions that do not yield valid template instantiations from a set of overload functions.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In the process of template argument deduction, a C++ compiler attempts to instantiate signatures of a number of candidate overloaded functions to make sure that exactly one overloaded function is available as a perfect match for a given function call.</p>
</blockquote>
<p>If an invalid argument or return type is formed during the instantiation of a function template, the instantiation is removed from the overload resolution set instead of causing a compilation error.<br>As long as there is one and only one function to which the call can be dispatched, the compiler issues no errors.</p>
<p>在对一个函数调用进行模板推导时，编译器会尝试推导所有的候选函数，以确保得到一个最完美的匹配。如果出现无效的模板参数，则会将该候选函数从重载决议集合中删除，只要最终得到了一个 perfect match ，编译就不会报错。</p>
<p><code>std::enable_if</code> 主要作用就是当某个 condition 成立时，enable_if可以提供某种类型。但是当 condition 不满足的时候，enable_if&lt;&gt;::type 就是未定义的，当用到模板相关的场景时，只会 instantiate fail，并不会编译错误，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;bool Cond, class T = void&gt; struct enable_if;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>alignas</strong></p>
<p><code>alignas</code> 说明符可应用于变量或非位域类数据成员的声明，或可应用于 class/struct/union 或枚举的定义。它不能应用于函数形参或 catch 子句的异常形参。</p>
<p>这种声明所声明的对象或类型的对齐要求，将等于用于该声明的所有 alignas 说明符中最严格（最大）的非零表达式，除非这会削弱类型的自然对齐。</p>
<p>若某个声明上的最严格（最大）alignas，比当它没有任何 alignas 说明符的情况下本应有的对齐更弱（即弱于其原生对齐，或弱于同一对象或类型的另一声明上的 alignas），则程序非良构：</p>
<p>无效的非零对齐，例如 alignas(3) 非良构。</p>
<p>同一声明上，弱于其他 alignas 的有效的非零对齐被忽略。</p>
<p>始终忽略 alignas(0)。</p>
<hr>
<p><code>std::function</code> 是一个可调用对象包装器，是一个类模板。它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟它们的执行。</p>
<p><code>std::function</code>可以取代函数指针的作用，可以延迟函数的执行，适合作为回调函数使用。</p>
<p><code>std::bind</code> 看作一个通用的函数适配器，接受一个可调用对象，生成一个新的可调用对象来<code>适应</code>原对象参数列表。</p>
<p><code>std::bind</code>将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。std::bind主要有两个作用：</p>
<ul>
<li>将可调用对象和其参数绑定成一个仿函数。</li>
<li>只绑定部分参数，减少可调用对象传入的参数。（Carry化）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void print_sum(int n1, int n2) &#123;</span><br><span class="line">    std::cout &lt;&lt; n1 + n2 &lt;&lt; &apos;\n&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::function&lt;void()&gt; f = std::bind(&amp;print_sum, 1, 1);</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>reference_wrapper</strong></p>
<p><code>reference_wrapper</code> 将引用包装成一个对象，即引用的包装器；可以包裹一个指向对象或者指向函数指针的引用，既可以通过拷贝构造，也可以通过赋值构造；</p>
<hr>
<p><code>size_t</code> &amp; <code>ssize_t</code></p>
<p><code>size_t</code>是一些C/C++标准在<code>stddef.h</code>中定义的，也是一个整型。<code>size_t</code>的真实类型与操作系统有关。<code>size_t</code>一般用来表示一种计数。sizeof操作符的结果类型是<code>size_t</code>，该类型保证能容纳实现所建立的最大对象的字节大小。</p>
<p>32位系统中被普遍定义为：typedef unsigned int size_t;为无符号整型，长度为4个字节。64位系统中定义为：typedef unsigned long size_t;为无符号长整型，长度为8个字节。</p>
<p><code>ssize_t</code>这个数据类型用来表示可以被执行读写操作的数据块的大小.它和<code>size_t</code>类似,但必需是signed.意即：它表示的是signed <code>size_t</code>类型的。</p>
<hr>
<p><strong>Lambda表达式</strong></p>
<p><code>Lambda 表达式</code>用于定义并创建匿名的函数对象，形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -&gt; 返回值类型 &#123;函数体&#125;</span><br></pre></td></tr></table></figure>
<p><em>函数对象参数</em>是传递给编译器自动生成的函数对象类的构造函数的。</p>
<p><em>操作符重载函数参数</em></p>
<p><em>mutable 或 exception 声明</em></p>
<p><em>-&gt; 返回值类型</em></p>
<p><em>{函数体}</em> 标识函数的实现，不能省略，但可以为空。</p>
<hr>
<p><strong>万能引用(Universal Reference)</strong></p>
<p>使用 <code>T&amp;&amp;</code> 类型的形参既能绑定右值，又能绑定左值。只有发生类型推导的时候，<code>T&amp;&amp;</code>才表示万能引用；否则，表示右值引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T &amp;&amp;param) &#123;</span><br><span class="line">    std::cout &lt;&lt; param &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int num = 2019;</span><br><span class="line">    func(num);</span><br><span class="line">    func(2020);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>引用折叠(Universal Collapse)</strong></p>
<p>一个模板函数，根据定义的形参和传入的实参的类型，可以有下面四中组合：</p>
<ul>
<li>左值-左值: 形参是左值引用，传入的实参是左值引用</li>
<li>左值-右值: 形参是左值引用，传入的实参是右值引用</li>
<li>右值-左值: 形参是右值引用，传入的实参是左值引用</li>
<li>右值-右值: 形参是右值引用，传入的实参是右值引用</li>
</ul>
<p>C++中不允许对引用再进行引用，所有的折叠引用最终都代表一个引用。</p>
<blockquote>
<p>规则是：如果任一引用为左值引用，则结果为左值引用。否则（即两个都是右值引用），结果为右值引用。</p>
</blockquote>
<hr>
<p><strong>完美转发(Perfect Forwarding)</strong></p>
<hr>
<p><strong>Tips</strong></p>
<table>
<thead>
<tr>
<th>Option name</th>
<th>Description                                   </th>
</tr>
</thead>
<tbody>
<tr>
<td>auto</td>
<td>for(auto x:range)会拷贝一份range元素，而不会改变range中元素</td>
</tr>
<tr>
<td>auto&amp;</td>
<td>需要修改range中元素 使用for(auto&amp; x:range) </td>
</tr>
<tr>
<td>const auto&amp;</td>
<td>只读取range中元素时使用，for(const auto&amp;x:range)不会进行拷贝，也不会修改range</td>
</tr>
<tr>
<td>const auto</td>
<td>需要拷贝元素，但不可修改拷贝出来的值时使用。for(const auto x:range)避免拷贝开销 </td>
</tr>
</tbody>
</table>
<p><code>compare_exchange_weak</code>和<code>compare_exchange_strong</code>则是著名的<code>CAS</code>。参数会要求在这里传入期待的数值和新的数值。对比变量的值和期待的值是否一致，如果是，则替换为新数值。否则将变量的值和期待的值交换。</p>
<p><code>compare_exchange_weak</code>版本的CAS允许偶然出乎意料的返回（比如在字段值和期待值一样的时候却返回了false），不过在一些循环算法中，这是可以接受的。通常它比起strong有更高的性能。</p>
<hr>
<p>Reference:</p>
<ol>
<li><a href="https://www.cnblogs.com/jiangbin/p/6986511.html" target="_blank" rel="noopener">C++中的RAII介绍</a></li>
<li><a href="https://www.jianshu.com/p/2b100d78a315" target="_blank" rel="noopener">C++之左值、右值、左值引用、右值引用</a></li>
<li><a href="https://www.cnblogs.com/sword03/p/10020344.html" target="_blank" rel="noopener">C++11 带来的新特性 （3）—— 关键字noexcept</a></li>
<li><a href="pan.baidu.com">EFFECTIVE+STL中文版：50条有效使用STL的经验_11577044</a></li>
<li><a href="https://www.jianshu.com/p/d19fc8447eaa" target="_blank" rel="noopener">[c++11]我理解的右值引用、移动语义和完美转发</a></li>
<li><a href="https://www.cnblogs.com/embedded-linux/p/5801999.html" target="_blank" rel="noopener">C之attribute用法</a></li>
<li><a href="https://isocpp.org/blog/2019/06/quick-q-differences-between-stdmake-unique-and-stdunique-ptr-with-new" target="_blank" rel="noopener">Differences between std::make_unique and std::unique_ptr with new</a></li>
<li><a href="https://zh.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener">cppreference: memory_order</a></li>
<li><a href="http://senlinzhan.github.io/2017/12/04/cpp-memory-order/" target="_blank" rel="noopener">理解 C++ 的 Memory Order</a></li>
<li><a href="https://tyzual.com/2019/02/11/mem-order/" target="_blank" rel="noopener">C++11 中的内存模型</a></li>
<li><a href="https://www.cnblogs.com/navono007/p/5746048.html" target="_blank" rel="noopener">C++11内存模型的粗略解释</a></li>
<li><a href="https://zh.cppreference.com/w/cpp/language/alignas" target="_blank" rel="noopener">alignas 说明符 (C++11 起)</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1387860" target="_blank" rel="noopener">C++中的万能引用和完美转发</a></li>
</ol>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>