<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="science &amp; art"><title>compile | Hexo</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-time">2019-01-08</div></div></div><div class="container post-header"><h1>compile</h1></div><div class="container post-content"><p>编译，利用编译程序从源语言编写的源程序产生目标程序的过程。计算机只认识1和0，编译程序把高级语言语言换成二进制。<br>编译分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。</p>
<p><strong>Lex</strong></p>
<p><code>Lex</code>是美国Bell实验室M.Lesk等人用C语言开发的一种词法分析器自动生成工具，提供一种供开发者编写词法规则的语言以及这种语言的翻译器。基本工作原理为：由正规式生成NFA，将NFA变换成DFA，DFA经化简后，模拟生成词法分析器。</p>
<p>Lex源程序分为三部分，三部分之间以符号%%分隔。以%开头的符号和关键字，或者词法规则段的各个规则一般顶着行首来写，前面没有空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一部分：定义段</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">第二部分：词法规则段</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">第三部分：辅助函数段</span><br></pre></td></tr></table></figure>
<p><em>第一部分定义段写法</em></p>
<p><em>第二部分词法规则段写法</em></p>
<p><em>第三部分辅助函数段写法</em></p>
<hr>
<p><strong>GCC/G++</strong></p>
<p><code>gcc [options] [filenames]</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>只编译，不链接成为可执行文件</td>
</tr>
<tr>
<td>-o</td>
<td>指定输出文件名称</td>
</tr>
<tr>
<td>-g</td>
<td>产生符号调试工具所必要的符号信息   </td>
</tr>
<tr>
<td>-O</td>
<td>对程序进行优化编译、链接</td>
</tr>
<tr>
<td>-O2</td>
<td>比 -O 更好的优化编译、链接</td>
</tr>
<tr>
<td>-Idirname</td>
<td>dirname 所指出的目录加入到程序头文件目录列表中，是在预编译过程中使用的参数</td>
</tr>
<tr>
<td>-E</td>
<td>预编译后停下来，生成后缀为 .i 的预编译文件</td>
</tr>
<tr>
<td>-c</td>
<td>编译后停下来，生成后缀为 .o 的目标文件</td>
</tr>
<tr>
<td>-S</td>
<td>汇编后停下来，生成后缀为 .s 的汇编源文件</td>
</tr>
<tr>
<td>-pedantic</td>
<td>gcc在编译不符合ANSI/ISO C 语言标准的源代码时，将产生相应的警告信息</td>
</tr>
<tr>
<td>-Wall</td>
<td>使 gcc 产生尽可能多的警告信息</td>
</tr>
<tr>
<td>-Werror</td>
<td>所有的警告当成错误进行处理</td>
</tr>
<tr>
<td>-Wcast-align</td>
<td>地址不需要对齐的指针指向一个地址需要对齐的变量地址时，则产生一个警告</td>
</tr>
<tr>
<td>-I</td>
<td>向 gcc 的头文件搜索路径中添加新的目录</td>
</tr>
<tr>
<td>-L</td>
<td>向 gcc 的库文件搜索路径中添加新的目录</td>
</tr>
<tr>
<td>-l</td>
<td>链接时装载函数库</td>
</tr>
<tr>
<td>-static</td>
<td>强制使用静态链接库</td>
</tr>
<tr>
<td>-shared</td>
<td>生成一个共享的目标文件</td>
</tr>
<tr>
<td>-g/-ggdb</td>
<td>不会将调试符号插入到生成的二进制代码中，因为这样会增加可执行文件的大小</td>
</tr>
<tr>
<td>-p/-pg</td>
<td>将剖析（Profiling）信息加入到最终生成的二进制代码中</td>
</tr>
<tr>
<td>-save-temps</td>
<td>保存编译过程中生成的一些列中间文件</td>
</tr>
</tbody>
</table>
<p><em>测试 example.c</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  long long int var = 1;</span><br><span class="line">  printf(&quot;It is not standard C code!/n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>编译原理之美</strong></p>
<p><code>前端</code>指的是编译器对程序代码的分析和理解过程。通常只跟语言的语法有关，跟目标机器无关。<code>前端</code>技术分为词法分析、语法分析和语义分析三个部分，主要涉及自动机和形式语言方面的基础的计算理论。</p>
<p><code>后端</code>生成目标代码的过程，跟目标机器有关。</p>
<p><code>词法分析</code></p>
<p>词法分析器分析整个程序字符串，当遇到不同的字符时，会驱使它迁移到不同的状态。</p>
<p><code>语法分析</code></p>
<p>词法分析是识别一个个的单词，而语法分析就是在词法分析的基础上识别出程序的语法结构。</p>
<p>程序有定义良好的语法结构，语法分析过程就是构造这么一棵树。程序就是一棵抽象语法树（Abstract Syntax Tree，AST）。<br>树的每个节点（子树）是一个语法单元，这个单元的构成规则就叫<code>语法</code>。每个节点还可以有下级节点。</p>
<p>AST让计算机很容易去处理。</p>
<hr>
<p>Reference:</p>
<ol>
<li><a href="http://www.cnblogs.com/ghjbk/p/6953619.html" target="_blank" rel="noopener">Yacc 与 Lex 快速入门（词法分析和语法分析）</a></li>
<li><a href="https://www.cnblogs.com/wp5719/p/5528896.html" target="_blank" rel="noopener">Lex使用指南</a></li>
<li><a href="https://www.cnblogs.com/testlife007/p/6555404.html" target="_blank" rel="noopener">gcc的使用简介与命令行参数说明</a></li>
<li><a href="">编译原理之美</a></li>
</ol>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script></body></html>